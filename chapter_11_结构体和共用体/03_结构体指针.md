# 03_结构体指针

一个指向结构体变量的指针，指向的是结构体变量的起始地址。除此以外，指针变量还可以指向结构体数组以及数组中的元素。

## 指向结构体变量的指针

```c
结构体类型 *指针名;
```

```c
// 定义一个指向struct student结构类型的p_stu指针变量
struct Student *p_stu;
```

指针指向的是结构体变量的地址，因此可以使用指针来访问结构体中的成员，方式有两种。

第一种方法是使用成员运算符`.`引用结构成员， 形式为`(*p_stu).成员名`。

```c
(*p_stu).num = 23201106;
```

注意，`*p_stu`一定放在括号内，这是因为成员运算符`.`的优先级最高，如果不使用括号，就会先执行`.`运算然后才是`*`运算。

第二种方法是使用指向运算符`->`引用结构成员，形式为`p_stu->成员名`。

```c
p_stu->num = 23201108;
```

> 在使用`->`引用成员时，要注意分析以下情况。
>
> - p_stu->grade：表示指向的结构体变量中成员`grade`的值。
> - p_stu->grade++：表示指向的结构体变量中成员`grade`的值，使用后该值加1。
> - ++p_stu->grade：表示指向的结构体变量中成员`grade`的值加1，计算后再进行使用。

总结一下，假如`student_1`为结构体变量，`p_stu`为指向结构体变量的指针，则以以下3种引用形式的效果是完全等价的。

- `student_1.成员名`
- `(*p_stu).成员名`
- `p_stu->成员名`

## 指向结构体数组的指针

结构体指针变量指向结构体数组时，指针变量的值就是结构体数组的首地址。还可以直接指向结构体数组中的元素，这时指针变量的值就是该结构体数组元素的首地址。

```c
// 定义一个结构体数组student_arr[5]，使用结构体指针指向该数组
struct Student *p_stu;
p_stu = student_arr;
```

因为数组不使用下标时表示的是数组的第一个元素的地址，所以指针指向数组的首地址。如果想利用指针指向第3个元素，则在数组名后附加下标，然后在数组名前使用取地址符号`&`。

```c
p_stu = &student_arr[2];
```

> `(++p_stu)->num`与`(p_stu++)->num`的区别在于：前者先执行`++`操作，使`p_stu`指向下一个元素的地址，然后取得该元素的成员值；后者先取得当前元素的成员值，再使`p_stu`指向下一个元素的地址。

## 结构体作为函数参数

使用函数时，其参数也可以是结构体变量。形式有3种：使用结构体变量作为函数参数；使用指向结构体变量的指针作为函数参数；使用结构体变量的成员作为函数参数。

### 使用结构体变量作为函数参数

结构体变量作为函数实参时，采取的是“值传递”方式，即会将结构体变量所占内存单元的内容全部顺序传递给形参，形参也必须是同类型的结构体变量。

```c
void print_str(struct Student stu);
```

在形参位置使用结构体变量，但是函数调用期间，形参也要占用内存单元。这种传递方式在空间和时间上开销都比较大。另外，根据函数参数传值方式，如果在函数内部修改了变量中成员的值，则改变的值不会返回到主调函数中。

### 使用指向结构体变量的指针作为函数参数

在使用结构体变量作为函数的参数时，在传值的过程中空间和时间的开销比较大，那么有没有一种更好的传递方式呢？有！就是使用结构体变量的指针作为函数的参数进行传递。

在传递结构体变量的指针时，只是将结构体变量的首地址进行传递，并没有将变量的副本进行传递。

```c
void print_str(struct Student *p_stu);
```

这样使用形参`p_stu`指针就可以引用结构体变量中的成员了。需要注意的是，因为传递的是变量的地址，如果在函数中改变成员中的数据，那么返回主调函数时变量会发生改变。

### 使用结构体变量的成员作为函数参数

该方式与普通变量作为实参是一样的，是传值方式传递（实参与形参类型一致）。

```c
print_str(student_1.score[0])
```



