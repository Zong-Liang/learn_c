# 03_内存泄露与内存丢失

## 内存泄露

使用`malloc`等函数分配过内存后，还需要使用`free`函数及时释放内存。如果不进行释放，就会造成内存泄漏，甚至会导致系统崩溃。

`free`函数可以实时地执行回收内存操作。如果程序很简单，程序结束之前不会使用过多的内存，不会降低系统的性能，可以不用写`free`函数。程序结束后，操作系统会自动完成释放的功能。但是在开发大型程序时，如果不及时通过`free`函数释放内存，后果是很严重的。例如，程序中可能要重复一万次分配10MB的内存，如果每次分配内存后都使用`free`函数及时释放用完的内存空间，那么整个程序只需要使用10MB内存就可以运行。如果不使用`free`函数释放用完的内存空间，整个程序就要使用100GB的内存！这其中包括绝大部分的虚拟内存，由于虚拟内存的操作需要读写磁盘，所以会极大地影响到系统的性能，甚至导致系统崩溃。

因此，实际开发中，使用`malloc`函数分配内存后，应及时地写出一个`free`函数释放内存。这是一个良好的编程习惯，不但在处理大型程序时非常有必要，也在一定程度上体现了程序的优美和健壮性。

## 内存丢失

```c
p_old = (int *)malloc(sizeof(int));
p_new = (int *)malloc(sizeof(int));
```

这两段代码创建了两块内存，并且将内存地址分别赋给了指针`p_old`和`p_new`，此时指针`p_old`和`p_new`分别指向两块内存。

```c
p_old = p_new;
```

则`p_old`指针就指向了`p_new`指向的内存地址。

```c
free(p_old);
```

由于`p_old`所指向的内存空间是原来`p_new`指向的，于是这块空间被释放了。但是`p_old`原来指向的那块内存空间还没有被释放（因为没有指针指向这块内存），这块内存就造成了丢失。

如何避免？

```c
p_old = (int *)malloc(sizeof(int));
p_new = (int *)malloc(sizeof(int));
free(p_old); // 释放p_old原来指向的内存
p_old = p_new; // 更新p_old指向新分配的内存
```

